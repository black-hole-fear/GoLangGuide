# [常见设计模式导图](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#title=常见设计模式导图) 

## 七大设计原则

### 开闭原则

定义：开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。

减少对已有代码的修改（比如已有方法、逻辑），提升扩展性；可以提高软件系统的可复用性及可维护性，同时减少对已有代码的影响。

方式一：可以采用继承、重写等方式。

方式二：还可以更多的依赖接口与抽象，不要依赖具体实现！！ 因为你依赖实现，改动只能改动具体实现。

### 依赖倒置原则

定义：依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，抽象不依赖细节，细节应该依赖抽象。

通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。

### 单一职责原则

定义：定单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。

举例：假设我们有一个 Class负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个Class来实现，进行解耦。后期需求变更维护互不影响。

这样的设计可以降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。总体来说就是一个 Class/Interface/Method 只负责一项职责。但实际情况很多时候是不符合单一职责的，因为会加大代码量！！以及让代码过于分散！

### 接口隔离原则

定义：接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。

接口隔离原则符合我们常说的高内聚、低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。

### 迪米特法则

定义：迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。

迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类， 而出现在方法体内部的类不属于朋友类。实体类之间尽量减少相互作用！！ 简单就是一句话，减少类之间的耦合，这也是为什么我们很多方法定义成private或者protect的原因！

### 里式替换原则

定义：里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为T1的对象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序P 在所有的对象o1都替换成 o2 时，程序 P 的行为没有发生变化，那么类型T2 是类型T1 的子类型。

定义重新理解：可以理解为一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下：引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。

子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。

子类中可以增加自己特有的方法。

当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。

当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。

## 设计模式分类

- 创建型：创建型模式，就是指用于描述“怎样创建对象”
- 结构型：用于描述如何将类或对象按某种布局组成更大的结构
- 行为型：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责

## 单例模式

定义：是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。

应用场景：J2EE标准中的ServletContext、ServletContextConfig等，Spring框架中的ApplicationContext、数据库的连接池等也都是单例模式。

- 饿汉式单例
- 懒汉式单例

## 工厂模式

- 简单工厂模式

是指有一个工厂对象，来根据传入的是什么对象类型，决定创建出哪一种产品类的实例，但它不属于23种设计模式

组成结构：工厂（CourseFactory）、抽象类产品（ICourse）、具体产品（JavaCourse）

- 工厂方法模式

是指定义一个创建对象的工厂接口，但让实现这个工厂接口的不同的具体工厂类来决定实例化哪个类，工厂方法让类的实例化推迟到具体的工厂类中进行

核心思想：将对象创建的逻辑下推到子类，就是创建多个子工厂

- 抽象工厂模式

是指创建工厂抽象类，定义产品族，产生多个具体子工厂，每个具体工厂创建一个产品族，即多个具体产品实例。

## 原型模式

- 概念

原型实例指定创建对象的种类，并通过拷贝这些原型创建新的实例，调用者不用知道任

何细节，不用调用构造函数。 

- 适用场景

初始化耗费资源多

new对象繁琐

构造方法复杂

- 浅克隆
- 实现方式
- 类实现Cloneable接口，调用clone方法，即可获得浅克隆对象。
- 优点
- 实现简单，速度快
- 缺点
- 仅拷贝对象本身，不拷贝对象中的引用指向的对象
- 单例对象再去使用浅克隆，会破坏单例

解决办法

- 覆盖clone方法，直接返回单例对象
- 单例类不使用原型方法创建
- 深克隆
- 实现方式
- 序列化再反序列化
- 对象转json，json再转回对象
- 自己手动重新创建浅克隆对象里引用的其他对象
- 优点
- 对象和对象中引用的对象都拷贝
- 缺点
- 实现比浅克隆复杂
- 性能比浅克隆慢
- 单例对象再去使用深克隆，会破坏单例
- 解决办法
- 单例类不使用原型方法创建
- 实际应用场景
- ArrayList的clone方法，实现深克隆
- HashMap的clone方法实现深克隆
- 缺点
- 必须使用克隆的方式
- 改变类的行为需要直接改代码，违反开闭原则
- 浅拷贝、深拷贝必须应用得当！
- 优点
- 性能优良，java自带的clone是基于内存二进制流的拷贝，比new一个对象性能强。
- 可以保存对象的状态，不用再重新初始化状态

## 代理模式

- 概念

指为其他对象提供一种代理，以控制对这个对象的访问，而代理对象在可以在客户端和目标对象之间起到中介的作用！！！也可以理解为代码增强，在原代码逻辑前后增加一些代码逻辑，而使调用者无感知

- 静态代理

静态代理手动实现代理，代理类需要与被代理类实现相同的接口，不易维护，一旦接口增加方法，目标对象和代理对象都需要修改。违背开闭原则。

- 动态代理
- JDK动态代理
- 概念
- 采用字节重组，重新生成对象来替代原始对象，以达到动态代理的目的
- 实现原理

1.获取被代理对象的引用，并且反射获取它所有的接口

2.jdk动态代理类重新生成一个新的类，同时新的类要实现被代理类实现的所有接口

3.动态生成java代码，根据新加的业务方法生成

4.编译新生成的class文件，重新运行

- 重点

JDK代理的目标对象必须要实现接口，因为JDK代理是根据被代理对象的所有接口去生成新的方法！但是Proxy.newProxyInstance返回的是接口类，而非实现，所以JDK只能代理接口！！

- CGLB动态代理
- 概念
- CGLib代理的目标对象不需要实现任何接口，它是通过动态继承目标对象实现动态代理
- 实现原理

\1. 创建被代理的类及方法；

\2. 创建一个实现接口 MethodInterceptor 的代理类，重写 intercept 方法；

\3. 创建获取被代理类的方法 getInstance(Object target);

\4. 获取代理类，调用代理类方法。

- 重点
- CGLib代理不需要被代理对象实现任何接口，它会重写被代理类的所有方法，所以不能代理final修饰的方法或者类，因为被final修饰后，表明这个类不能被继承
- 静态代理与动态代理的区别

\1. 静态代理只能通过手动完成代理操作，如果被代理类增加了新的方法，代理类需要同步增加，违背开闭原则

\2. 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。

- 优点

能将代理对象与真实被调用的目标对象分离，降低系统的耦合程度，易于扩展，在增强被代理对象职责的同时，可以起到保护被代理对象的作用

- 缺点

增加系统的复杂度，会在客户端与目标对象之间增加一个代理对象，请求速度变慢

## 适配器模式

适配器模式是**作为两个不兼容的接口之间的桥梁**。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式**涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能**。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

这种模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。其别名为包装器。

优点：

1. **可以让任何两个没有关联的类一起运行**
2. **提高了类的复用**
3. **增加了类的透明度**
4. **灵活性好**

缺点：

1. **过多地使用适配器，会让系统非常零乱，不易整体把握**。比如，明明调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
2. **由于Java至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类**。

使用场景：

有动机地修改一个正常运行的接口，这时应该考虑使用适配器模式。

注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

## 策略模式

- 概念

对算法家族进行封装，算法间可以互相替换，不会影响使用算法的用户

- 适用场景

有很多类，而这些类的区别仅仅在于行为不同

一个系统需要动态选择其中一种算法

- 应用场景

DispatcherServlet

Arrays类的parallelSort方法使用Comparator类实现策略模式

Spring的Resource接口，不同类型的资源用不同的获取方式

Spring的InstantiationStartegy接口

- 优点

符合开闭原则

避免使用过多if else、switch

提高算法的保密性和安全性

- 缺点

客户必须先知道有哪些策略，并且自己决定选哪个策略

代码中会产生很多策略类，增加维护难度



参考：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1668702039685-27f200dd-36d7-474b-85aa-efb142934adf.png)

**光星の博客**

Java,Spring,Spring Boot,Spring Cloud,JDK,MySQL,Mybatis,Redis,Linux,RabbitMQ,Docker,Maven,Nginx,微服务,架构设计,项目管理

http://blog.gxitsky.com/

**一文带你理解常用的23种设计模式**

https://baijiahao.baidu.com/s?id=1661505290125455712&wfr=spider&for=pc



![img](https://cdn.nlark.com/yuque/0/2022/svg/22219483/1668702039697-454e7b0f-b5af-4299-aee1-3fb93d411113.svg)源自 Thoughts 文档，点击注册

[常见设计模式导图](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#slate-title)

[七大设计原则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761da235b6d50012504c98)

[开闭原则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dde35b6d50012504cea)

[依赖倒置原则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761e8835b6d50012504ceb)

[单一职责原则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dcf35b6d50012504cb3)

[接口隔离原则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dcf35b6d50012504cbf)

[迪米特法则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dcf35b6d50012504cc7)

[里式替换原则](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dcf35b6d50012504ccf)

[设计模式分类](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dcf35b6d50012504ce2)

[单例模式](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761f2835b6d50012504d10)

[工厂模式](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761eec35b6d50012504cf5)

[原型模式](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#63761dcf35b6d50012504ce9)

[代理模式](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#637620fe35b6d50012504d91)

[适配器模式](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#6376222a35b6d50012504e3c)

[策略模式](https://thoughts.teambition.com/share/637623174d2d2a0042e508a0#6376229d35b6d50012504e49)


 